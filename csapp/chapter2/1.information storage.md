# 1. Addressing and Byte Ordering

### Addressing
- int는 4bytes, 0x100 | 0x101 | 0x102 | 0x103 의 주소가 있다면 int x인 경우 &x = 0x100을 가리킨다. 
### Byte Ordering
0x01234567를 기준으로 하면
- Little Endian (INTEL)
    0x100|0x101|0x102|0x103
    ---|---|---|---
    67|45|23|01

- Big Endian (IBM, Oracle)
    0x100|0x101|0x102|0x103
    ---|---|---|---
    01|23|45|67

### Byte Ordering이 쓸모 있어지는 3가지
1. 서로 다른 machine이 network를 통해 통신할 때, 한 machine은 big endian을 쓰고, 다른 machine은 little endian을 사용하면, big endian으로 된 bit 덩어리를 little endian으로 
해석하게 되면 의미가 달라진다. 
2. machine-level program에서 byte sequence를 해석할 때 필요하다. disassembler로 machine code를 사람이 읽을 수 있는 instruction코드로 변환해준다. 이 instruction에서 int data를 표현하는 byte sequence가 존재하는 경우, little인지 아니면 big인지에 따라 해석이 달라진다. 
3. 일반적인 type system을 우회하는 프로그램이 있는 경우, little인지 big인지에 따라 사람한테 보여지는 byte order가 달라진다. /system_study/csapp/chapter2/experiments/print_bytes.c 참고. print_bytes.c에서 unsigned char * 타입을 이용하여 1byte씩 데이터를 읽어서 화면에 출력해주는 프로그램이다. 현재 나의 노트북은 INTEL processor를 사용하고 있기 때문에 little endian으로 출력이 된다. 일반적인 type system을 우회한다는 의미는 int, float, int *등 다양한 type들이 존재하지만 print_bytes함수를 호출할 때, 먼저 void *로 변환하고 unsigned char *로 변환해서 1byte씩 읽어오는데 casting을 이용해서 일반적인 type system을 우회하고 있다. 

# 2. Representing Strings
### string에서의 byte ordering과 '\0'문자
- string의 마지막에 terminating byte인 0x00이 존재한다. 

# 3. Representing Codes
```C
int sum(int x, int y)
{
    return x + y;
}
```
- Linux 32, Windows, Sun, Linux 64와 같이 서로 다른 machine에서 위의 코드를 컴파일하면 서로 다른 machine code가 생성된다. 또, 같은 processor를 사용하지만 서로 다른 OS를 사용하면 서로 다른 code를 생성하고, binary compatible하지 않다. 

# 4. Bit-Level Operations in C
- C언어: |(OR), &(AND), ~(NOT), ^(XOR)
- a^a=0
- Bit-Level operation은 주로 masking operation을 구현하기 위해 사용된다. /system_study/csapp/chapter2/experiments/masking.c 참고. 보통 hex 기준 0과 F를 주로 사용한다. 
- 0x12345678에서 LSB만 남기고 싶으면 0x12345678 & 0xFF = 0x00000078이 된다. 
- /system_study/csapp/chapter2/experiments/bit_set_clear.c 참고

# 5. Logical Operations in C
- C에서는 logical operation인 ||(OR), &&(AND), !(NOT) 연산자가 존재한다. 
- logical operator들은 첫번째 argument에서 결과가 정해지고, 두번째 argument와 상관 없이 결과가 유지되면 첫번째 argument만 보고 결정한다. 
    - EX: 0 && 1에서 0이 있으면 무조건 0이므로 1을 보고 판단하지 않는다. 
- == 연산자를 bit level operation과 logical operation을 통해 구현할 수 있다. 
equal_operation.c 참고.

# 6. Shift operations in C
- << left shift operator: 오른쪽 끝을 0으로 채운다. 
- \>> right shift operator
    - logical: 왼쪽 끝을 0으로 채운다.
    - arithmetic: signed data type인 경우,  MSB의 값에 따라서 왼쪽 끝에 채워지는 bit이 다르다. 양수인 경우 0으로 채워지고, 음수인 경우 1로 채워진다. 
> 거의 모든 경우에는 arithmetic하게 연산한다. 