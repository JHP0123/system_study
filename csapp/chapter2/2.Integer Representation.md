Integer Representations
---
- 기계는 같은 bit 덩어리가 존재해도 어떤 방식으로 해석하느냐에 따라 의미적으로 달라진다. signed, unsigned, short, long, char 등... 아래는 CSAPP 교재 안에서 기계들이 bit 덩어리들을 어떻게 해석하는지를 정의한 것이다. 
    Symbol|Meaning
    ---|---
    B2T|Binary to Two's Complement
    B2U|Binary to Unsigned 
    U2B|Unsigned to Binary
    U2T|Unsigned to Two's Complement
    T2U|Two's Complement to Unsigned
    T2B|Two's Complement to Binary
    TMAX|Max in Two's Complement
    TMIN|Min in Two's Complement
    UMAX|Max in Unsigned
- bit을 int 기계가 어떻게 encode하고 casting하는지를 위의 정의를 이용하여 기계 동작 원리를 이해한다.

# 1. Integral Data Types
- 32 bit system에서는 char(1byte) < short(2byte) < int(4byte) = long = int32_t < int64_t(8byte) 이고, 64 bit system에서는 char(1byte) < short(2byte) < int(4byte) = int32_t < long(8byte) = int64_t 이다. 
# 2. Unsigned Encodings
- ![equation](https://latex.codecogs.com/svg.image?\tilde{x}=[x_{w-1},x_{w-2},\dots,x_0])라고 할 때


![eq](https://latex.codecogs.com/svg.image?B2U_w(\vec{x})\triangleq\sum_{i=0}^{w-1}x_i2^i)

- Ex
    - ![eq](https://latex.codecogs.com/svg.image?B2U_4[0011]=0\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0=3)

# 3. Two's Complement Encodings
- $\tilde{x}$ = [$x_{w-1}$, $x_{w-2}$, ..., $x_0$]라고 할 때

![eq](https://latex.codecogs.com/svg.image?B2T_w(\vec{x})\triangleq-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i)

- Ex
    - $B2T_4([1011]) = -1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -5$
    - $TMax_4 = B2T_4([0111]) = 2^2 + 2^1 + 2^0 = 7$
    - $TMin_4 = B2T_4([1000]) = -1 \cdot 2^3 = -8$
- TMax와 TMin의 관계
    - $|TMin| = |TMax| + 1$
- UMax와 TMax의 관계
    - $UMax = 2TMax + 1$
```C
short x = 12345;
short y = -x;
```
- 위의 경우, 12345는 0x3039를 의미한다. - 를 붙여서 -12345는 0xCFC7를 의미한다. 
이들을 bit로 표현하면 [0011|0000|0011|1001]와 [1100|1111|1100|0111]이다. 보면 12345의 bit를 모두 반전시키고(~) 1을 더한다.
 ```C
 -12345(signed)
 53191(unsigned)
 ```
 - 위 숫자의 경우, -12345 = [1100|1111|1100|0111]이고 53191 = [1100|1111|1100|0111]이다. 두 숫자 모두 bit의 나열이 같다. 하지만 signed의 경우 **B2T**를, unsigned의 경우 **B2U**를 적용시켜 기계가 encode한다. 
# 4. Conversions between Signed and Unsigned
```C
short int x = -12345;
unsigned short ux = (unsigned short) x;
```
- bit의 순서와 값은 같지만 기계가 이 bit를 어떻게 해석하느냐에 따라 달라진다. 
- 12345(signed)의 bit 값을 구한 다음, 그 bit 값을 unsigned로 encode하면 된다. 

![eq](https://latex.codecogs.com/svg.image?T2U_w(x)=B2U_w(T2B_w(x)))

- 반대도 마찬가지(U2T)
--- 
- $TMin_w \le x \le TMax_w$일 때, $T2U$를 수식으로 표현하면 

![eq](https://latex.codecogs.com/svg.latex?%5Cdisplaystyle%20U2T_w(u)%3D%5Cbegin%7Bcases%7Du%2C%26u%5Cle%20TMax_w%5C%5Cu-2%5Ew%2C%26u%3ETMax_w%5Cend%7Bcases%7D)

**or**

![eq](https://latex.codecogs.com/svg.image?T2U_w(x)=x+x_{w-1}2^w)

-   Ex
    - $T2U_{16}(-12{,}345) = -12{,}345 + 2^{16} = 53{,}191$
---
- $U2T$인 경우에도 $0 \le u \le UMax_w$일 때,

$$
U2T_w(u) =
\begin{cases}
u, & u \le TMax_w \\
u - 2^w, & u > TMax_w
\end{cases}
$$
$$or$$
$$
U2T_w(u) = -u_{w-1} 2^w + u
$$

# 5. Signed versus Unsigned in C
## A. Intuitive Casting
- C에서는 unsigned와 signed 사이의 casting을 허용한다 
- Explicit Casting
```C
int x, xx;
unsigned y, yy;

y = (unsigned) x;
xx = (int) yy;
```
- Implicit Casting
```C
unsigned x = 2147483648;
int y = x;
```
위의 경우, x는 signed 에서 unsigned로 implicit casting이 된다.  
$$
U2T_{32}(2147483648) = -1\cdot 2^{32} + 2147483648 = -2147483648
$$ 
- printf에서 %d, %u는 각각 signed와 unsigned를 받아서 출력하는 directives이다. 그래서 %d자리에 unsigned를 넣으면 implicit하게 signed로 casting하고, %u에 signed를 넣으면 unsigned로 casting한다. 

## B. Nonintuitive Casting
연산을 할 때 2개의 operand중 하나가 unsigned이고 다른 하나가 signed이면, signed를 unsigned로 casting해서 연산한다. 대표적인 non-intuitive casting은 relational operator.
- 모든 피연산자가 signed이면 signed로 계산.
- 둘 중 하나라도 unsigend이면 모두 unsigned로 계산

- Ex
    - $-1<0U$
        - 모두 unsigned로 casting해서 계산한다. $T2U_{32}(-1) = -1 + 1 \cdot2^{32} = 4,294,967,295$이므로 $	4,294,967,296 < 0$은 $false$.
    - $ 2147483647u > -2147483647-1$
        - $-2147483647-1$를 unsigned로 casting해서 연산한다.  $T2U_{32}(-2147483647-1) = (-2147483647-1) + 1 \cdot2^{32} = 2147483648$이므로 $2147483647 > 2147483648$는 $false$.
    - $2147483647 > (int) 2147483648U$
        - $(int) 2147483648U$는 $U2T$를 통해 $-2147483647-1$이 된다. $true$.

# 6. Expanding the Bit Representation of a Number
서로 다른 word size를 가지는 integer끼리 변환하면서 값을 유지하는 것이 가능하다. 
예를 들어, $signed\ 2\ byte\ data\ type$을 $signed\ 4\ byte\ data\ type$으로 변환하면서 값은 그대로 유지하는 것은 가능하다. 하지만 signed <-> unsigned는 좀 다르다. 
## A. Extension for Signed/Unsigned
```C
short s = -12345;   // -12345
int i = s;          // -12345

unsigned short us = 12345;  // 12345
unsigned ui = us;           // 12345
```
- 값은 유지되고, 데이터 타입의 크기가 커졌다. 
- short인 경우 $0xCFC7$이고, int로 extension하면 2byte가 4byte가 되므로 $0xFFFFCFC7$이 된다. F가 붙는 이유는 음수를 유지해야 값이 유지되기 때문이다.  
- unsigned short인 경우는 양수이므로 extension이 되었을 때 MSB쪽에 0으로 채워진다. 
- 2.2_sign_extension 참고.

## B. Signed to Unsigned Extension (including vice versa)
다른 크기의 data size로 변환하는데 signed에서 unsigned로 변환되거나 unsigned에서 signed로 변환되는 경우)
```C
short a = -12345;   // -12345
unsigned b = a;     // 0xCFC7 -> size up -> 0xFFFFCFC7 -> 
                    // T2U_32(-12345) = -12345 + 2^32 = 4,294,954,951
```
- **short(signed + 2 bytes)에서 unsigned(unsigned + 4 bytes)로 변환할 때, 먼저 2 byte에서 4 byte로 size up을 시킨 다음, bit encoding을 한다.**

# 7. Truncating Numbers
Extension을 통해 추가 bit를 하는 것과 반대로 Truncating을 해서 bit를 생략/삭제하는 연산. 

---
- Unsigned를 Truncating하는 경우
$$
B2U_k([x_{k-1}, x_{k-2}, \dots, x_0])
=
B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k
$$
- Signed를 Truncating하는 경우
$$
B2T_k([x_{k-1}, x_{k-2}, \dots, x_0])
=
U2T_k\!\left(
B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k
\right)
$$
---
**signed인 경우 먼저 bit를 unsigned로 바꾸고, $mod\ 2^k$를 한 다음 two's complement로 encoding한다.**

# 8. Advice on Signed versus Unsigned
위에서 본 것과 같이, casting이 직관적으로 다가오지 않는 경우가 많다. 이를 방지하기 위해서는 **unsigned를 사용하지 않는 것이다.** C는 unsigned를 지원하지만 JAVA와 같이 어떤 언어에서는 signed만 지원한다. 하지만 unsigned는 다음의 경우 도움이 된다. 
#### 1.대수적 해석(encoding)없이 byte 덩어리 그대로 보고 싶을 때
#### 2. 메모리의 address는 unsigned이므로, system programming을 할 때
